<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 空谷芝兰</title>
    <link>https:ruichunjie.github.io/posts/</link>
    <description>Recent content in Posts on 空谷芝兰</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Apr 2019 14:26:57 +0800</lastBuildDate>
    
	<atom:link href="https:ruichunjie.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>浅谈双亲委派模型</title>
      <link>https:ruichunjie.github.io/2019/parentsmodel20190423/</link>
      <pubDate>Tue, 23 Apr 2019 14:26:57 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/parentsmodel20190423/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;隔了半个月没写过博客了，这段时间在补充以前的坑，总感觉心里空落落的，今天来学一下双亲委派模型吧。
定义 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;双亲委派模型的工作流程是：
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; * 如果一个类加载器收到了类加载的请求，它不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; * 每个层次的类加载器都是如此。所有的加载请求都应该传送到顶层的启动类加载器中。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; * 只有当父加载器反馈自己无法完成这个加载请求，子加载器才会尝试自己去加载。
作用 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性。类随着它的类加载器一起具备了一种带有优先级的层次关系。
结构 启动类加载器(Bootstrap ClassLoader) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;由C++语言实现，负责将存放在/lib目录中，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机按照文件名识别的类库记载到虚拟机内存中。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接用null代替。
扩展类加载器(Extension ClassLoader) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;由Java sun.misc.Launcher$ExtClassLoader实现，负责加载&amp;lt;JAVA_HOME＞/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库。
应用程序类加载器(Application ClassLoader) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader.getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。负责加载用户类路径ClassPath上所指定的类库，开发者可以直接使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
实现原理 ClassLoader#loadClass()
public abstract class ClassLoader { ... public Class&amp;lt;?&amp;gt; loadClass(String name) throws ClassNotFoundException { return loadClass(name, false); } protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { Class&amp;lt;?&amp;gt; c = findLoadedClass(name); if (c == null) { ... try { if (parent !</description>
    </item>
    
    <item>
      <title>面试宝典</title>
      <link>https:ruichunjie.github.io/2019/question20190410/</link>
      <pubDate>Wed, 10 Apr 2019 23:21:34 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/question20190410/</guid>
      <description>简答 1.java什么时候用重载，什么时候用重写？
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;遵循开闭原则，Spring中的getBean，可以传BeanName和Class
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;父子类之间，模板和包装器模式，遵循开闭原则
2.举例一个更倾向于使用抽象接口类，而不是使用接口的设计场景？
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;抽象类可以增加实现，接口不能增加实现。抽象类可以有用在public方法中调用private方法，防止private方法被子类实现
3.在java中，为什么不允许从静态方法中访问非静态变量？
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。在一个类的静态成员中去访问其非静态成员之所以会出错是因为在类的非静态成员不存在的时候类的静态成员就已经存在了，访问一个内存中不存在的东西当然会出错。
4.软件架构中的上层应用指哪些层，客户端属于上层应用么？
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;架构有前端层，后端层，中间层，客户端是最顶层就是上层，如果在中间层或后端层，就可能不是
5.掌握设计模型中创建型，结构型，行为型之间的根本区别
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;创建型封装对象创建细节，结构型梳理对象与对象之间的关系，行为型梳理过程流程。
6.单例模式双重检查锁为什么要做两次非空检测？
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;两个线程同时进入方法， 可能同时判断是空，进入锁，如果锁内不做判断，第一次创建实例，第二次可能又会创建，实例会创建两次，第一次判断是性能优化，锁内的非空为了防止反复创建实例。
7.单例模式双重检查锁中synchronized为什么锁住的是class, 可以是int 或者Object么
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Class在JVM层面,只load一次，有全局共享锁，一旦锁住，就会受到保护。
8.工厂类需要构造方法私有么？
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;工厂类是不是需要私有构造方法，取决于场景。需要为单例，需要私有化，如果不需要是单例，就不需要私有化。在大部分场景中是需要私有化的。
9.抽象工厂中的产品结构等级和产品族的理解
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;产品等级结构是相同结构，相同特点的多种产品的纵性比较，产品族是相同品牌或者具有某种关联的一类。
10.使用原型模式解决最大的麻烦
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;解决在开发中重复代码的利用率
11.实现代理模式的底层逻辑是什么
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;代理模式底层逻辑，找一个代理为目标代理对象提供代理，并进行增强。静态代理需要手动生成一个类，动态代理是自动生成一个类。
12.JDK 代理需要实现接口，Cglib不需要？
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; JDK代理不实现接口没法知道代理的方法，没法对代理的方法进行反射，Cglib代理类需要重写被代理类，所以要求被代理类不能被final修饰
面试 1.受检异常与不受检异常的区别
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;受检异常必须要处理，比如SQLException,IOException
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不受检异常不是必须要捕获
2.了解软引用，弱引用，虚引用，强引用
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;强引用被回收的情况:1&amp;gt;脱离作用域;2&amp;gt;设置为null,并不再被引用
public class ReferenceDemo{ static Object strongRef = new Object(); public static void main(String args[]){ Object obj = strongRef; strongRef = null; System.gc(); System.out.println(&amp;quot;gc之后:&amp;quot;+obj); //gc之后java.lang.Object@4b1210ee,此时因为obj还引用了strongRef所以不会被回收 } }  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;软引用在发生OOM异常前才会被回收
public class ReferenceDemo{ public static void main(String args[]){ Object softRef = new Object(); SoftReference softReference = new SoftReference(softRef); System.</description>
    </item>
    
    <item>
      <title>Map详情分析</title>
      <link>https:ruichunjie.github.io/2019/map20190410/</link>
      <pubDate>Wed, 10 Apr 2019 19:56:03 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/map20190410/</guid>
      <description>Map HashMap &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为Null(多条会覆盖);允许多条记录的值为 Null。非同步的。
TreeMap &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;能够把它保存的记录根据键(key)排序,默认是按升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。
Hashtable &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;与HashMap类似,不同的是:key和value的值均不允许为null;它支持线程的同步
LinkedHashMap &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;保存了记录的插入顺序,key和value均允许为空，非同步的
常用API   方法 描述   clear() 从Map中删除所有映射   remove(Object key) 从Map中删除键和关联的值   put(Object key,Object value) 将指定值与指定键相关联   putAll(Map t) 将指定Map中的所有映射复制到此map   entrySet() 返回Map中所包含映射的Set视图。Set中的每个元素都是一个Map.Entry对象，可以使用getKey()和getValue()方法(还有setValue()方法)访问后者的键元素和值元素   values() 返回map中所包含值的Collection视图。删除Collection中的元素还将删除Map中相关的映射(键和值)   get(Object key) 返回与指定键相关联的值   containsKey(Object key) 如果Map包含指定键的映射，则返回true   containsValue(Object Value) 如果此Map将一个或多个键映射到指定值，则返回true   isEmpty() 如果Map中不包含键值映射，则返回true   size() 返回键值映射的数目</description>
    </item>
    
    <item>
      <title>List详情分析</title>
      <link>https:ruichunjie.github.io/2019/list20190410/</link>
      <pubDate>Wed, 10 Apr 2019 18:26:27 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/list20190410/</guid>
      <description>List &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;List是一个有序的集合，和set不同的是，List允许存储项的值为空，也允许存储相等值的存储项
ArrayList &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ArrayList是一个数组实现的列表，特点是查询很快，插入和删除很慢。
Vector &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Vector就是ArrayList的线程安全版，它的方法前都加了synchronized锁。
LinkedList &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LinkedList继承于AbstractSequentialList,和ArrayList一个套路。内部维护了3个成员变量，一个是当前链表的头节点，一个是尾部节点，还有是链表长度。
总结 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;List的3个特性  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* 1.是按顺序查找  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* 2.允许存储项为空  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* 3.允许多个存储项的值相等  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LinkedList和ArrayList对比 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* ArrayList是由数组实现的，方便查找，返回数组下标对应的值即可，适用于多查找的场景  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* sLinkedList由链表实现，插入和删除方便，适用于多次数据替换的场景</description>
    </item>
    
    <item>
      <title>Set详情分析</title>
      <link>https:ruichunjie.github.io/2019/set20190410/</link>
      <pubDate>Wed, 10 Apr 2019 16:55:21 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/set20190410/</guid>
      <description>Set &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。
HashSet &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;线程不安全，存取速度快。底层是以hash表实现的。哈希表存放的是哈希值。HashSet不存入重复元素的规则，使用hashcode() 和equals()
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当试图把对象加入HashSet时，HashSet会使用对象的HashCode来判断对象加入的位置。同时也会与其他已经加入的对象的hashCode进行比较。哈希值一样会继续比较equals()方法，如果结果为true，HashSet就视为同一个元素，否则不是同一元素。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add()返回的是boolean类型。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;HashSet和ArrayList集合中都有判断元素是否相同的方法(boolean. contains(Object o))。HashSet使用了hashCode()和equals()方法，ArrayList使用了equal()方法
TreeSet &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;红-黑树的数据结构，默认对元素进行自然排序（String）。如果在比较的时候两个对象返回值为0，那么元素重复。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;红黑树的规则: 左小右大
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;比较时有两种方式:1&amp;gt;元素自身具备比较性，实现Comparable接口；2&amp;gt;容器具有比较性，实现Comparator接口。当两种形式都存在时，以comparator的比较方式为主。比较时通过return 0来判断唯一性，所以不能直接return 0
LinkedHashSet &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;会保存插入的顺序。</description>
    </item>
    
    <item>
      <title>queue详情分析</title>
      <link>https:ruichunjie.github.io/2019/queue20190410/</link>
      <pubDate>Wed, 10 Apr 2019 10:25:46 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/queue20190410/</guid>
      <description>Queue的实现 1. 没有实现的阻塞接口: 实现了java.util.Queue接口和java.util.AbstractQueue接口 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;内置的不阻塞队列: PriorityQueue 和ConcurrentLinkedQueue
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PriorityQueue类实质上维护了一个有序列表，加入到Queue中的元素根据它们的天然排序(通过其java.util.Comparable实现)或者根据传递给构造函数的java.util.Comparator实现来定位。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ConcurrentLinkedQueue是基于链接节点的，线程安全的队列。并发访问不需要同步，因为在队列的尾部添加元素，并从头部删除它们，所以不需要知道队列的大小,ConcurrentLinkedQueue对公共集合的共享访问可以工作的很好。收集关于队列大小的信息很慢，需要遍历队列。采用CAS机制(compareAndSwapObject原子操作)
2. 实现的阻塞接口: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;java.util.concurrent中加入了BlockingQueue接口和五个阻塞队列类它实质上就是一种带有一点扭曲的 FIFO 数据结构。不是立即从队列中添加或者删除元素，线程执行操作阻塞，直到有空间或者元素可用。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* ArrayBlockingQueue: 一个由数组支持的有界队列，在构造时需要指定容量,并可以选择是否需要公平性，如果公平参数设置为true，等待时间最长的线程会优先得到处理(其实就是通过ReentrantLock设置为true来达到公平性:即等待时间最长的线程会先操作)。公平性会使性能付出代价，只有在非常需要的时候使用。基于数组，FIFO原则排序。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* LinkedBlockingQueue: 一个由链接节点支持的可选有界队列,容量是没有上限的(在不指定时，容量为Integer.MAX_VALUE),FIFO排序元素
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* PriorityBlockingQueue: 一个由优先级堆支持的无界优先级队列，不再是先进先出。队列没有上限，put时不会受阻
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* DelayQueue: 一个由优先级堆支持的,基于时间的调度队列。只有在延迟期满才能提取元素，头部是延迟期满后保存时间最长的Delayed元素。如果延迟没有期满，则队列没有头部，poll返回null。当一个元素的getDelay(TimeUnit.NANOSECONDS)方法返回一个小于或等于零的值时，出现期满。poll移除该元素，
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* SynchronousQueue: 一个利用BlockingQueue接口的简单聚集(rendezvous)机制
阻塞队列操作   操作 作用 状态   add 添加一个元素 队列已满，抛出IIIegaISlabEepeplian异常   remove 移除并返回队列头部的元素 队列已空，抛出NoSuchElementException异常   element 返回队列头部的元素 队列已空，抛出NoSuchElementException异常   offer 添加一个元素，并返回true 队列已满，返回false   poll 移除并访问队列头部的元素 队列为空，返回null   peek 返回队列头部的元素 队列为空，返回null   put 添加一个元素 队列已满，阻塞   take 移除并返回队列头部的元素 队列为空，阻塞   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;阻塞队列的操作根据响应方式可以分为三类add, remove和element操作在视图在为一个已满队列添加元素或从空队列中取得元素时抛出异常。</description>
    </item>
    
    <item>
      <title>云丘山</title>
      <link>https:ruichunjie.github.io/2019/firstwan20190408/</link>
      <pubDate>Mon, 08 Apr 2019 18:21:12 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/firstwan20190408/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2019.04.08 与美丽动人的娟红小姐姐去云丘山游玩。 </description>
    </item>
    
    <item>
      <title>Spring MVC初体验</title>
      <link>https:ruichunjie.github.io/2019/spring-mvc20190408/</link>
      <pubDate>Mon, 08 Apr 2019 16:06:42 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/spring-mvc20190408/</guid>
      <description>Spring MVC 处理流程 1. DispatcherServlet是SpringMVC中的前端控制器(Front Controller),负责接收Request并将Request转发给对应的处理组件 2.HandlerMapping 是SpringMVC中完成url到Controller映射的组件，DispatcherServlet接收Request,然后从HandlerMapping查找处理Request的Controller 3. Controller处理Request,并返回ModelAndView,Controller是SpringMVC中处理Request的组件，ModelAndView是封装结果视图的组件 4. 视图解析器解析ModelAndView对象并返回对应的视图给客户端 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;容器初始化时会建立所有 url 和 Controller 中的 Method 的对应关系，保存到 HandlerMapping 中，用户请求是根据 Request 请求的 url 快速定位到 Controller 中的某个方法。在 Spring 中先将 url 和 Controller 的对应关 系,保存到 Map中。Web 容器启动时会通知 Spring 初始化容器(加载 Bean 的定义信息和初始化所有单例 Bean),然后 SpringMVC 会遍历容器中的 Bean，获 取每一个 Controller 中的所有方法访问的 url，然后将 url 和 Controller 保存到一个 Map 中;这样就可以根据 Request 快速定位到 Controller，因为最终处理 Request 的是 Controller 中的方法，Map 中只保留了 url 和 Controller 中的对应关系，所以要根据 Request 的 url 进一步确认 Controller 中的 Method，这一步工作的原理就是拼接 Controller 的 url(Controller 上@RequestMapping 的值)和方法的 url(Method 上 @RequestMapping 的值)，与 request 的 url 进行匹配，找到匹配的那个方法;确定处 理请求的 Method 后，接下来的任务就是参数绑定，把 Request 中参数绑定到方法的形 式参数上，这一步是整个请求处理过程中最复杂的一个步骤。</description>
    </item>
    
    <item>
      <title>Spring细节</title>
      <link>https:ruichunjie.github.io/2019/springxijie20190402/</link>
      <pubDate>Tue, 02 Apr 2019 22:08:03 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/springxijie20190402/</guid>
      <description>FactoryBean &amp;amp; BeanFactory &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;BeanFactory:Bean工厂，是一个工厂(Factory),Spring IOC容器的最顶层接口就是这个BeanFactory。作用是管理Bean，即实例化,定位,配置应用程序中的对象及建立这些对象间的依赖。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;FactoryBean:工厂Bean,是一个Bean,作用是产生其他bean实例,通常情况下，这种Bean仅提供一个工厂方法,该方法用来返回其他Bean实例。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当用户使用容器本身时，可以使用转义字符”&amp;amp;”来得到 FactoryBean 本身，以区别通过 FactoryBean 产生的实例对象和 FactoryBean 对象本身。在 BeanFactory 中通过如下代码定义了该转义字符: String FACTORY_BEAN_PREFIX = &amp;ldquo;&amp;amp;&amp;ldquo;;
//工厂Bean，用于产生其他对象 public interface FactoryBean&amp;lt;T&amp;gt; { //获取容器管理的对象实例 @Nullable T getObject() throws Exception; //获取Bean工厂创建的对象的类型 @Nullable Class&amp;lt;?&amp;gt; getObjectType(); //Bean工厂创建的对象是否是单态模式，如果是单态模式，则整个容器中只有一个实例 //对象，每次请求都返回同一个实例对象 default boolean isSingleton() { return true; } }  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;FactoryBean 的实现类有非常多，比如:Proxy、RMI、JNDI、ServletContextFactoryBean 等等， FactoryBean 接口为 Spring 容器提供了一个很好的封装机制，具体的 getObject()有不同的实现类根 据不同的实现策略来具体提供
autowiring &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Spring IOC 容器提供了两种管理 Bean 依赖关系的方式: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1)、显式管理:通过 BeanDefinition 的属性值和构造方法实现 Bean 依赖关系管理。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2)、autowiring:Spring IOC 容器的依赖自动装配功能，不需要对 Bean 属性的依赖关系做显式的声明，只需要在配置好 autowiring 属性，IOC 容器会自动使用反射查找属性的类型和名称，然后基于属性的类型或者名称来自动匹配容器中管理的 Bean，从而自动地完成依赖注入。</description>
    </item>
    
    <item>
      <title>Spring AOP源码初了解</title>
      <link>https:ruichunjie.github.io/2019/spring-aop20190402/</link>
      <pubDate>Tue, 02 Apr 2019 13:59:07 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/spring-aop20190402/</guid>
      <description>1.Spring AOP中的概念 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.切面(Aspect):官方定义为&amp;rdquo;一个关注点的模块化，这个关注点可能横切多个对象&amp;rdquo;。切面在ApplicationContext中aop:aspect来配置。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;连接点(Joinpoint):程序执行过程中的某一行为。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.通知(Advice):切面对于某个连接点所产生的动作，其中，一个“切面”可以包含多个“Advice”。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3.切入点(Pointcut):匹配连接点的断言，在AOP中通知和一个切入点表达式关联。切面中的所有通知所关注的连接点表达式来决定。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;4.目标对象(Target Object): 被一个或多个切面所通知的对象。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;5.AOP代理(AOP Proxy):Spring AOP 有两种代理方式，jdk动态代理和CGLib代理。默认情况下,实现了接口采用JDK动态代理，反之，采用CGLib代理。 强制使用CGLib代理需要将aop:config的proxy-target-class属性设为true &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;6.前置通知(Before Advice):在某连接点(JoinPoint)之前执行的通知，但这个通知不能阻止连接点前的执行。ApplicationContext在aop:aspect里面使用aop:before元素进行声明。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;7.后置通知(After Advice):当某连接点退出的时候执行的通知(不论是正常返回还是异常退出)。ApplicationContext在aop:aspect里面用aop:after元素进行声明。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;8.返回后通知(After Return Advice):在某连接点正常完成后执行的通知，不包括抛出异常的情况。(非void) ApplicationContext在aop:aspect里面使用进行声明。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;9.环绕通知(Around Advice):包围一个连接点的通知。类似Web中Servlet规范中的Filter的doFilter方法。可以在方法的调用前后完成自定义的行为，也可以选择不执行。ApplicationContext中在aop:aspect里使用aop:around元素进行声明。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;10.异常通知(After Throwing Advice):在方法抛出异常退出时执行的通知。ApplicationContext中在aop:aspect里面使用aop:after-throwing元素进行声明。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可以将多个通知应用到一个目标对象上，即可以将多个切面织入同一目标对象。
2.实现方式 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用AOP基于两种方式，一种是比较方便和强大的注解方法，另一种是xml配置
注解 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.xml中声明激活自动扫描组件功能，同时激活自动代理功能。
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot; xmlns:util=&amp;quot;http://www.springframework.org/schema/util&amp;quot; xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd&amp;quot;&amp;gt; &amp;lt;context:component-scan base-package=&amp;quot;com.gupaoedu&amp;quot;/&amp;gt; &amp;lt;context:annotation-config /&amp;gt; &amp;lt;/beans&amp;gt;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.为Aspect切面类添加注解
@Component //声明这是一个切面Bean，AnnotaionAspect是一个面，由框架实现的 @Aspect public class AnnotaionAspect { private final static Logger log = Logger.getLogger(AnnotaionAspect.class); //配置切入点,该方法无方法体,主要为方便同类中其他方法使用此处配置的切入点 //切点的集合，这个表达式所描述的是一个虚拟面（规则） //就是为了Annotation扫描时能够拿到注解中的内容 @Pointcut(&amp;quot;execution(* com.</description>
    </item>
    
    <item>
      <title>Spring DI源码初了解</title>
      <link>https:ruichunjie.github.io/2019/spring-di20190402/</link>
      <pubDate>Tue, 02 Apr 2019 09:37:55 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/spring-di20190402/</guid>
      <description>1.依赖注入发生的时间 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当Spring IOC容器完成了Bean定义资源的定位,载入和解析注册后，IOC容器中已经管理类bean定义的相关数据，但是此时IOC容器还没有对所管理的Bean进行依赖注入，依赖注入在一下两种情况发生:1)用户第一次调用getBean()方法时，IOC容器触发依赖注入。2)当用户在配置文件中将元素配置了lazy-init =false属性，即让容器在解析注册Bean定义时进行预实例化，触发依赖注入。
2. 源码 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.AbstractBeanFactory#getBean()入口
//获取IOC容器中指定名称的Bean @Override public Object getBean(String name) throws BeansException { //doGetBean才是真正向IoC容器获取被管理Bean的过程 return doGetBean(name, null, null, false); } //真正实现向IOC容器获取Bean的功能，也是触发依赖注入功能的地方 protected &amp;lt;T&amp;gt; T doGetBean(final String name, @Nullable final Class&amp;lt;T&amp;gt; requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException { //根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖 //如果指定的是别名，将别名转换为规范的Bean名称 final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. //先从缓存中取是否已经有被创建过的单态类型的Bean //对于单例模式的Bean整个IOC容器中只创建一次，不需要重复创建 Object sharedInstance = getSingleton(beanName); //IOC容器创建单例模式Bean实例对象 if (sharedInstance !</description>
    </item>
    
    <item>
      <title>Spring IOC源码初了解</title>
      <link>https:ruichunjie.github.io/2019/spring-ioc20190331/</link>
      <pubDate>Sun, 31 Mar 2019 14:12:15 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/spring-ioc20190331/</guid>
      <description>1.IOC 与DI &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IOC(Inversion of Control)控制反转:原来代码里要实现的对象创建,依赖的代码，反转给容器实现.
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DI(Dependency Injection)依赖注入:对象被动接受依赖类而不是自己主动去找。也就是说对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的对象注入给它。
2. Spring 核心容器类图 1&amp;gt; BeanFactory &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;BeanFactory定义了 IOC 容器的基本功能规范，BeanFactory 有三 个重要的子类:ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory , ListableBeanFactory 接口表示这些 Bean 是可列表化的，而 HierarchicalBeanFactory 表示的是 这些 Bean 是有继承关系的，也就是每个 Bean 有可能有父 Bean。AutowireCapableBeanFactory 接 口定义 Bean 的自动装配规则。这三个接口共同定义了 Bean的集合、Bean之间的关系、以及 Bean行为。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在使用 Spring IOC 容器的时候我们还需要区别两个概念:BeanFactory 和 FactoryBean，其中 BeanFactory 指的是 IOC 容器的编程抽象，比如 ApplicationContext，XmlBeanFactory 等，这些都 是 IOC 容器的具体表现，需要使用什么样的容器由客户决定,但 Spring 为我们提供了丰富的选择。 FactoryBean 只是一个可以在 IOC 而容器中被管理的一个 Bean,是对各种处理过程和资源使用的抽 象,FactoryBean 在需要时产生另一个对象，而不返回 FactoryBean 本身,我们可以把它看成是一个抽象 工厂，对它的调用返回的是工厂生产的产品。所有的 FactoryBean 都实现特殊的 org.springframework.beans.factory.FactoryBean 接口，当使用容器中 FactoryBean 的时候，该容 器不会返回 FactoryBean 本身,而是返回其生成的对象。Spring 包括了大部分的通用资源和服务访问抽 象的 FactoryBean 的实现，其中包括:对 JNDI 查询的处理，对代理对象的处理，对事务性代理的处理， 对 RMI 代理的处理等，这些我们都可以看成是具体的工厂,看成是 Spring 为我们建立好的工厂。也就是 说 Spring 通过使用抽象工厂模式为我们准备了一系列工厂来生产一些特定的对象,免除我们手工重复的 工作，我们要使用时只需要在 IOC 容器里配置好就能很方便的使用了。</description>
    </item>
    
    <item>
      <title>Mini版Spring v1.0 </title>
      <link>https:ruichunjie.github.io/2019/myspring20190327/</link>
      <pubDate>Wed, 27 Mar 2019 18:57:33 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/myspring20190327/</guid>
      <description>实现思路 1.配置application.properties文件 scanPackage=com.gupao.demo  2.配置web.xml文件 &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;web-app xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns=&amp;quot;http://java.sun.com/xml/ns/j2ee&amp;quot; xmlns:javaee=&amp;quot;http://java.sun.com/xml/ns/javaee&amp;quot; xmlns:web=&amp;quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&amp;quot; xsi:schemaLocation=&amp;quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&amp;quot; version=&amp;quot;2.4&amp;quot;&amp;gt; &amp;lt;display-name&amp;gt;Web Application&amp;lt;/display-name&amp;gt; &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;mymvc&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;com.gupao.mvcframework.servlet.MyDispatcherServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;application.properties&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;mymvc&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; &amp;lt;/web-app&amp;gt;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MyDispatcherServlet是仿照DispatcherServlet写的仿照类
3.自定义Annotation /** * @Author:ChunJieRen * @Date:2019/3/25 10:35 * @Description: 仿照@Autowired */ @Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface MyAutowired { String value() default &amp;quot;&amp;quot;; } /** * @Author:ChunJieRen * @Date:2019/3/25 09:55 * @Description: 仿照@Controller */ @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface MyController { String value() default &amp;quot;&amp;quot;; } /** * @Author:ChunJieRen * @Date:2019/3/25 10:05 * @Description: 仿照@RequestMapping */ @Target({ElementType.</description>
    </item>
    
    <item>
      <title>接下来一年的计划</title>
      <link>https:ruichunjie.github.io/2019/shenghuo20190327/</link>
      <pubDate>Wed, 27 Mar 2019 17:50:06 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/shenghuo20190327/</guid>
      <description>关于工作 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 目前来说，应该是我很窘迫的时期了。在这边感觉学不到有用的东西了。只是因为前几年跳槽太快的缘故，决定再留一年稳定下吧，趁着一年我要把基础知识学完，并且把架构师进阶教程学完。今年九月初试着在新的地点投投简历吧。如果能在感情方面有突破，就等到明年吧。
关于学习 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;现在学习分两大类: 1.基础知识 2.架构进阶。基础知识今年必须学完十本书。架构进阶应该能够熟练应用并且深入源码学习。
关于地点 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今年在九月份前，决定去哪个城市稳定生活吧。备选:太原，西安，宁波，苏州，杭州</description>
    </item>
    
    <item>
      <title>初识Spring</title>
      <link>https:ruichunjie.github.io/2019/springbegin20190323/</link>
      <pubDate>Sat, 23 Mar 2019 18:42:35 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/springbegin20190323/</guid>
      <description>1.Spring中的设计模式   设计模式 一句话归纳 举例   工厂模式(Factory) 只对结果负责，封装创建过程 BeanFactory,Calender   单例模式(Singleton) 保证独一无二 ApplicationContext, Calender   原型模式(Prototype) 拔一根猴毛,吹出千万个 ArrayList, PrototypeBean   代理模式(Proxy) 找人办事，增强职责 ProxyFactory, JdkDynamicAopProxy, CglibAopProxy   委派模式(Delegate) 干活算你的(普通员工),功劳算我的(项目经理) DispatcherServlet,BeanDefinitionParserDelegate   策略模式(Strategy) 用户选择,结果统一 InstantiationStrategy   模板模式(Template) 流程标准化，自己实现定制 JdbcTemplate,HttpServlet   适配器模式(Adapter) 兼容转化头 AdvisorAdapter, HandlerAdapter   装饰器模式(Decorator) 包装,同宗同源 BufferedReader,InputStream,OutputStream,HttpHeadResponseDecorator   观察者模式(Observer) 任务完成时通知 ContextLoaderListener   2.Spring编程思想总结   Spring思想 应用场景(特点) 一句话归纳   OOP Object Oriented Programming(面向对象编程)用程序归纳总结生活中的一切事物 封装, 继承, 多态   BOP Bean Oriented Programming(面向Bean编程)面向Bean(普通的java类)设计程序，解放程序员 一切从Bean开始   AOP Aspect Oriented Programming(面向切面编程)找出多个类中有一定规律的代码，开发时拆开，运行时合并。面向切面编程，即面向规则编程 解耦，专人做专事   IOC Inversion of Control(控制反转)将new对象的动作交给Spring管理，并由Spring保存已创建的对象(IOC容器) 转交控制权(即控制权反转)   DI/DL Dependency Injection(依赖注入)或者Dependency Lookup(依赖查找)依赖注入/依赖查找， Spring不仅保存自己创建的对象，而且保存对象与对象之间的关系, 注入即赋值，主要三种赋值方法,构造方法,set方法,直接赋值 赋值   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Spring 则立志于全方面的简化 Java 开发。 对此，主要采取了 4 个关键策略:</description>
    </item>
    
    <item>
      <title>八达岭长城</title>
      <link>https:ruichunjie.github.io/2019/greatewall20190323/</link>
      <pubDate>Sat, 23 Mar 2019 16:16:28 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/greatewall20190323/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2019.03.23与晓军童鞋一起游玩了长城 </description>
    </item>
    
    <item>
      <title>设计模式总结</title>
      <link>https:ruichunjie.github.io/2019/alldesign20190322/</link>
      <pubDate>Fri, 22 Mar 2019 17:12:13 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/alldesign20190322/</guid>
      <description>GOF 23种设计模式   分类 设计模式   创建型 工厂方法模式(Factory Method), 抽象工厂模式(Abstract Factory), 建造者模式(Builder), 原型模式(Prototype), 单例模式(Singleton)   结构型 适配器模式(Adapter), 桥接模式(Bridge),组合模式(Composite),装饰者模式(Decorator),门面模式(Facede), 享元模式(Flyweight), 代理模式(Proxy)   行为型 解释器模式(Interpreter), 模版方法模式(Template Method), 责任链模式(Chain of Responsibility), 命令模式(Command), 迭代器模式(Iterator), 调解者模式(Mediator), 备忘录模式(Memento), 观察者模式(Observer), 状态模式(State), 策略模式(Strategy), 访问者模式(Visitor)</description>
    </item>
    
    <item>
      <title>装饰者模式和观察者模式</title>
      <link>https:ruichunjie.github.io/2019/decorationandobserve20190321/</link>
      <pubDate>Thu, 21 Mar 2019 09:09:43 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/decorationandobserve20190321/</guid>
      <description>1.装饰者模式
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;装饰者模式(Decorator Pattern)是指在不改变原有对象的基础之上，将功能附加到对象上，提供了比继承更有弹性的替代方案(扩展原有对象的功能)，属于结构型模式。装饰者在代码程序中适用于以下场景:
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1、用于扩展一个类的功能或给一个类添加附加职责。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2、动态的给一个对象添加功能，这些功能可以再动态的撤销。
public abstract class Battercake(){ protected abstract String getMsg(); protected abstract int getPrice(); } public class BaseBattercake extends Battercake{ protected String getMsg(){ return &amp;quot;煎饼&amp;quot;; } public int getPrice(){ return 5; } } public abstract class BattercakeDecorator extends Battercake{ private Battercake battercake; public BattercakeDecorator(Battercake battercake){ this.battercake = battercake; } protected abstract void doSomething(); protected String getMsg(){ return this.battercake.getmsg(); } protected int getPrice(){ return this.battercake.getPrice(); } } public class EggDecorator extends BattercakeDecorator{ public EggDecorator(Battercake battercake){ super(battercake); } protected void doSomething(){} protected String getMsg(){ return super.</description>
    </item>
    
    <item>
      <title>模板模式和适配器模式</title>
      <link>https:ruichunjie.github.io/2019/templateandadapter20190320/</link>
      <pubDate>Wed, 20 Mar 2019 12:39:09 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/templateandadapter20190320/</guid>
      <description>1.模板模式
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;模板模式通常又叫模板方法模式(Template Method Pattern)是指定义一个算法的骨 架，并允许子类为一个或者多个步骤提供实现。模板方法使得子类可以在不改变算法结 构的情况下，重新定义算法的某些步骤，属于行为性设计模式。模板方法适用于以下应 用场景:
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1)一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2)各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复。
public interface RowMapper&amp;lt;T&amp;gt;{ T mapRow(ResultSet rs, int rowNum) throws Exception; } public abstract class JdbcTemplate{ private DataSource dataSource; public JdbcTemplate(DataSource dataSource){ this.dataSource = dataSource; } public List&amp;lt;?&amp;gt; executeQuery(String sql, RowMapper&amp;lt;?&amp;gt; rowMapper, Object[] values){ try{ //1.获得连接 Connection conn = this.getConnection(); //2.创建语句集 PreparedStatement pstm = this.createPrepareStatement(conn,sql); //3.执行语句集 ResultSet rs = this.executeQuery(pstm,values); //4.处理结果集 List&amp;lt;?&amp;gt; result=this.paresResultSet(rs,rowMapper); //5.关闭结果集 this.closeResultSet(rs); //6.关闭语句集 this.closeStatement(pstm); //7.关闭连接 this.closeConnection(conn); return result; }catch(Exception e){ e.</description>
    </item>
    
    <item>
      <title>委派模式和策略模式</title>
      <link>https:ruichunjie.github.io/2019/delegateandstrategy20190320/</link>
      <pubDate>Wed, 20 Mar 2019 05:10:19 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/delegateandstrategy20190320/</guid>
      <description>1.委派模式
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;委派模式(Delegate Pattern)的基本作用就是负责任务的调度和分配任务，跟代理模式很像，可以看做是一种特殊情况下的静态代理的全权代理，但是代理模式注重过程，而委派模式注重结果。不属于GOF23种设计模式之一，行为型模式，Delegate，Dispatch 结尾的一般都是代理模式。如BeanDefinitionParserDelegate
/** * 模拟SpringMVC 的 DispatcherServlet */ public class SystemController{ public void logout(){} } public class DispatcherServlet extends HttpServlet{ private void doDispatch(HttpServletRequest request, HttpServletResponse response ) throws Exception{ String uri = request.getRequestURI(); String mid = request.getParameter(&amp;quot;mid&amp;quot;); if(&amp;quot;logout&amp;quot;.equals(mid)){ new SystemController().logout(); }else{ response.getWriter().write(&amp;quot;404&amp;quot;); } } protected void service(HttpServletRequest request,HttpServletResponse response)throw ServletException,IOException{ try{ doDispatch(req,resp); }catch(Exception e){ e.printStackTrace(); } } }  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;web-app xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns=&amp;quot;http://java.sun.com/xml/ns/j2ee&amp;quot; xmlns:javaee=&amp;quot;http://java.sun.com/xml/ns/javaee&amp;quot; xmlns:web=&amp;quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&amp;quot; xsi:schemaLocation=&amp;quot;http://java.sun.com/xml/ns/j2ee http://java.</description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>https:ruichunjie.github.io/2019/proxy20190319/</link>
      <pubDate>Tue, 19 Mar 2019 12:55:52 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/proxy20190319/</guid>
      <description>1.代理模式
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;代理模式(Proxy Pattern)是指为其他对象提供一种代理，以控制对这个对象的访问。代理对象在客服端和目标对象之间起到中介作用，代理模式属于结构型设计模式。使用 代理模式主要有两个目的:一保护目标对象，二增强目标对象。有静态代理和动态代理。
2.静态代理
3.动态代理
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;jdk动态代理
public class JDKproxy implements InvocationHandler{ privte Person target; public Object getInstance(Person target) throws Exception{ this.target = target; Class&amp;lt;?&amp;gt; clazz = target.getClass(); return Proxy.newProxyInstance(clazz.getClassLoader(),clazz.getInterfaces(),this); } public Object invoke(Object proxy, Method method,Object[] args)throws Exception{ before(); Object obj = method.invoke(this.target,args); after(); return obj; } public void before(){} public void after(){} }  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;JDK Proxy 生成对象的步骤
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1)拿到被代理对象的引用并获取所有的接口，反射获取
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2)JDK Proxy类重新生成新的类，同时新的类要实现被代理类所实现的所有的接口
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3)动态生成Java代码，把新加的业务逻辑方法由一定的逻辑代码去调用(在代码中体现)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;4)编译新生成的Java代码.class
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;5)重新加载到JVM中运行
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;自定义生成动态反射
/** * @Author:ChunJieRen * @Date:2019/3/13 16:56 * @Description: 1.</description>
    </item>
    
    <item>
      <title>原型模式</title>
      <link>https:ruichunjie.github.io/2019/prototype20190319/</link>
      <pubDate>Tue, 19 Mar 2019 12:33:42 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/prototype20190319/</guid>
      <description>1.原型模式
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原型模式(Prototype Pattern)是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原型模式主要适用于以下场景:
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1、类初始化消耗资源较多。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2、new 产生的一个对象需要非常繁琐的过程(数据准备、访问权限等)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3、构造函数比较复杂。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;4、循环体中生产大量对象时。
2.原型模式的实现
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1)简单克隆
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;复制的不是值，而是引用的地址。浅克隆。只是完整 复制了值类型数据，没有赋值引用对象。换言之，所有的引用对象仍然指向原来的对象
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2)深度克隆
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;克隆破坏单例模式
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ArrayList 就实现了 Cloneable 接口
public Object clone() { try { ArrayList&amp;lt;?&amp;gt; v = (ArrayList&amp;lt;?&amp;gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn&#39;t happen, since we are Cloneable throw new InternalError(e); } }  </description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https:ruichunjie.github.io/2019/singleton20190318/</link>
      <pubDate>Mon, 18 Mar 2019 22:32:49 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/singleton20190318/</guid>
      <description>1.什么是单例模式
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 单例模式(Singleton Pattern)是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。单例模式是创建型模式。 ServletContext,ServletContextConfig,ApplicationContext,数据库的连接池都是单例形式
2.单例的实现
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1)饿汉式单例
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 在类加载时就立刻初始化，并且创建单例对象，绝对线程安全。优点是没有加任何锁，执行效率高，在用户体验上，比饿汉式要好，缺点是类加载时就初始化，不管用与不用都占着空间，浪费了内存。适用单例对象较少的情况。
public class HungryStaticSingleton{ private static final HungrySingleton hungrysingleton = new HungrySingleton(); private HungrySingleton(){} public static HungrySingleton getInstance(){return hungrysingleton;} }  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2)懒汉式单例 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;被外部类调用的时候内部类才会加载。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; synchronized 静态方法
public class LazySimpleSingleton{ private LazySimpleSingleton(){} private static LazySimpleSingleton lazy = null; public synchronized static LazySimpleSingleton getInstance(){ if(null == lazy){ lazy = new LazySimpleSingleton(); } return lazy; } }  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 双重检查锁
public class LazyDoubleCheckSingleton{ private volatile static LazyDoubleCheckSingleton lazy = null; private LazyDoubleCheckSingleton(){} public static LazyDoubleCheckSingleton getInstance(){ if(null == lazy){ synchronized(LazyDoubleCheckSingleton.</description>
    </item>
    
    <item>
      <title>mybatis基础</title>
      <link>https:ruichunjie.github.io/2019/mybatis20190317/</link>
      <pubDate>Sun, 17 Mar 2019 22:32:49 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/mybatis20190317/</guid>
      <description>1.什么是mybatis
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MyBatis 是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。
2.使用mybatis
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1) 编程式
String resource = &amp;quot;org/mybatis/example/mybatis-config.xml&amp;quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt; &amp;lt;!DOCTYPE configuration PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot; &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;environments default=&amp;quot;development&amp;quot;&amp;gt; &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt; &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;/&amp;gt; &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${driver}&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${url}&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${username}&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${password}&amp;quot;/&amp;gt; &amp;lt;/dataSource&amp;gt; &amp;lt;/environment&amp;gt; &amp;lt;/environments&amp;gt; &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&amp;quot;org/mybatis/example/BlogMapper.xml&amp;quot;/&amp;gt; &amp;lt;/mappers&amp;gt; &amp;lt;/configuration&amp;gt;  DataSource dataSource = BlogDataSourceFactory.</description>
    </item>
    
    <item>
      <title>工厂模式</title>
      <link>https:ruichunjie.github.io/2019/factorydesignprinciple20190316/</link>
      <pubDate>Sat, 16 Mar 2019 22:32:49 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/factorydesignprinciple20190316/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Spring中用到了很多设计模式，如工厂模式，装饰者模式，代理模式，单例模式，委派模式，策略模式，适配器模式，模板方式模式，观察者模式。设计思路，Spring IOC 工厂，单例，装饰器 。Spring AOP 代理， 观察者。 Spring MVC 委派，适配器，Spring JDBC模板方法。
1.简单工厂模式
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;简单工厂模式(Simple Factory Pattern)是指由一个工厂对象 决定创建出哪一种产品类的实例。属于创建型模式，但它不属于GOF，23种设计模式。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;工厂类负责创建的对象较少。客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心。但是工厂类的职责相对过重，增加新的产品时需要修改工厂类的判断逻辑，违背开闭原则。不易于扩展过于复杂的产品结构。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;代码过于简单，不演示了，在JDK中存在Calendar.getInstance()方法
public static Calendar getInstance() { return createCalendar(TimeZone.getDefault(),	Locale.getDefault(Locale.Category.FORMAT)); } private static Calendar createCalendar(TimeZone zone, Locale aLocale) { CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale) .getCalendarProvider(); if (provider != null) { try { return provider.getInstance(zone, aLocale); } catch (IllegalArgumentException iae) { // fall back to the default instantiation } } Calendar cal = null; if (aLocale.</description>
    </item>
    
    <item>
      <title>软件架构七大原则</title>
      <link>https:ruichunjie.github.io/2019/sevendesignprinciple20190311/</link>
      <pubDate>Mon, 11 Mar 2019 22:32:49 +0800</pubDate>
      
      <guid>https:ruichunjie.github.io/2019/sevendesignprinciple20190311/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;虽然总是说设计模式，然而感觉在开发中却很少用到。想抽点时间深入学习下设计模式。而在学习设计模式前，先来了解下软件架构七大原则。
1.开闭原则
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;开闭原则(Open-Closed Principle, OCP)是指一个软件实体如类、模块和函数应该对 扩展开放，对修改关闭。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调 的是用抽象构建框架，用实现扩展细节。实现开闭原则的核心思想就是面向抽象编程。如下示例:
/** * 课程接口 */ public interface ICourse{ Integer getId(); String getName(); Double getPrice(); } /** * java课程 如果此时java课程做活动怎么写呢？ */ public class JavaCourse implements ICourse{ private Integer Id; private String name; private Double price; public JavaCourse(Integer id, String name, Double price){ this.Id = id; this.name = name; this.price = price; } public Integer getId(){ return Id; } public String getName(){ return name; } public String getPrice(){ return price; } } /** * java折扣类 */ public class JavaDiscountCourse extends JavaCourse{ public JavaDiscountCourse(Integer id, String name, Double price){ super(id,name,price); } public Double getOriginPrice(){ return super.</description>
    </item>
    
  </channel>
</rss>