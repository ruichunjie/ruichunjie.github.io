<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 空谷芝兰</title>
    <link>https://ruichunjie.github.io/posts/</link>
    <description>Recent content in Posts on 空谷芝兰</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 Mar 2019 17:50:06 +0800</lastBuildDate>
    
	<atom:link href="https://ruichunjie.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>接下来一年的计划</title>
      <link>https://ruichunjie.github.io/2019/shenghuo20190327/</link>
      <pubDate>Wed, 27 Mar 2019 17:50:06 +0800</pubDate>
      
      <guid>https://ruichunjie.github.io/2019/shenghuo20190327/</guid>
      <description>关于工作 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 目前来说，应该是我很窘迫的时期了。在这边感觉学不到有用的东西了。只是因为前几年跳槽太快的缘故，决定再留一年稳定下吧，趁着一年我要把基础知识学完，并且把架构师进阶教程学完。今年九月初试着在新的地点投投简历吧。
关于学习 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;现在学习分两大类: 1.基础知识 2.架构进阶。基础知识今年必须学完十本书。架构进阶应该能够熟练应用并且深入源码学习。
关于地点 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今年在七月份前，决定去哪个城市稳定生活吧。备选:太原，西安，宁波，苏州，杭州</description>
    </item>
    
    <item>
      <title>初识Spring</title>
      <link>https://ruichunjie.github.io/2019/springbegin20190323/</link>
      <pubDate>Sat, 23 Mar 2019 18:42:35 +0800</pubDate>
      
      <guid>https://ruichunjie.github.io/2019/springbegin20190323/</guid>
      <description>1.Spring中的设计模式   设计模式 一句话归纳 举例   工厂模式(Factory) 只对结果负责，封装创建过程 BeanFactory,Calender   单例模式(Singleton) 保证独一无二 ApplicationContext, Calender   原型模式(Prototype) 拔一根猴毛,吹出千万个 ArrayList, PrototypeBean   代理模式(Proxy) 找人办事，增强职责 ProxyFactory, JdkDynamicAopProxy, CglibAopProxy   委派模式(Delegate) 干活算你的(普通员工),功劳算我的(项目经理) DispatcherServlet,BeanDefinitionParserDelegate   策略模式(Strategy) 用户选择,结果统一 InstantiationStrategy   模板模式(Template) 流程标准化，自己实现定制 JdbcTemplate,HttpServlet   适配器模式(Adapter) 兼容转化头 AdvisorAdapter, HandlerAdapter   装饰器模式(Decorator) 包装,同宗同源 BufferedReader,InputStream,OutputStream,HttpHeadResponseDecorator   观察者模式(Observer) 任务完成时通知 ContextLoaderListener   2.Spring编程思想总结   Spring思想 应用场景(特点) 一句话归纳   OOP Object Oriented Programming(面向对象编程)用程序归纳总结生活中的一切事物 封装, 继承, 多态   BOP Bean Oriented Programming(面向Bean编程)面向Bean(普通的java类)设计程序，解放程序员 一切从Bean开始   AOP Aspect Oriented Programming(面向切面编程)找出多个类中有一定规律的代码，开发时拆开，运行时合并。面向切面编程，即面向规则编程 解耦，专人做专事   IOC Inversion of Control(控制反转)将new对象的动作交给Spring管理，并由Spring保存已创建的对象(IOC容器) 转交控制权(即控制权反转)   DI/DL Dependency Injection(依赖注入)或者Dependency Lookup(依赖查找)依赖注入/依赖查找， Spring不仅保存自己创建的对象，而且保存对象与对象之间的关系, 注入即赋值，主要三种赋值方法,构造方法,set方法,直接赋值 赋值   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Spring 则立志于全方面的简化 Java 开发。 对此，主要采取了 4 个关键策略:</description>
    </item>
    
    <item>
      <title>八达岭长城</title>
      <link>https://ruichunjie.github.io/2019/greatewall20190323/</link>
      <pubDate>Sat, 23 Mar 2019 16:16:28 +0800</pubDate>
      
      <guid>https://ruichunjie.github.io/2019/greatewall20190323/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2019.03.23与晓军童鞋一起游玩了长城 </description>
    </item>
    
    <item>
      <title>设计模式总结</title>
      <link>https://ruichunjie.github.io/2019/alldesign20190322/</link>
      <pubDate>Fri, 22 Mar 2019 17:12:13 +0800</pubDate>
      
      <guid>https://ruichunjie.github.io/2019/alldesign20190322/</guid>
      <description>GOF 23种设计模式   分类 设计模式   创建型 工厂方法模式(Factory Method), 抽象工厂模式(Abstract Factory), 建造者模式(Builder), 原型模式(Prototype), 单例模式(Singleton)   结构型 适配器模式(Adapter), 桥接模式(Bridge),组合模式(Composite),装饰者模式(Decorator),门面模式(Facede), 享元模式(Flyweight), 代理模式(Proxy)   行为型 解释器模式(Interpreter), 模版方法模式(Template Method), 责任链模式(Chain of Responsibility), 命令模式(Command), 迭代器模式(Iterator), 调解者模式(Mediator), 备忘录模式(Memento), 观察者模式(Observer), 状态模式(State), 策略模式(Strategy), 访问者模式(Visitor)</description>
    </item>
    
    <item>
      <title>装饰者模式和观察者模式</title>
      <link>https://ruichunjie.github.io/2019/decorationandobserve20190321/</link>
      <pubDate>Thu, 21 Mar 2019 09:09:43 +0800</pubDate>
      
      <guid>https://ruichunjie.github.io/2019/decorationandobserve20190321/</guid>
      <description>1.装饰者模式
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;装饰者模式(Decorator Pattern)是指在不改变原有对象的基础之上，将功能附加到对象上，提供了比继承更有弹性的替代方案(扩展原有对象的功能)，属于结构型模式。装饰者在代码程序中适用于以下场景:
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1、用于扩展一个类的功能或给一个类添加附加职责。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2、动态的给一个对象添加功能，这些功能可以再动态的撤销。
public abstract class Battercake(){ protected abstract String getMsg(); protected abstract int getPrice(); } public class BaseBattercake extends Battercake{ protected String getMsg(){ return &amp;quot;煎饼&amp;quot;; } public int getPrice(){ return 5; } } public abstract class BattercakeDecorator extends Battercake{ private Battercake battercake; public BattercakeDecorator(Battercake battercake){ this.battercake = battercake; } protected abstract void doSomething(); protected String getMsg(){ return this.battercake.getmsg(); } protected int getPrice(){ return this.battercake.getPrice(); } } public class EggDecorator extends BattercakeDecorator{ public EggDecorator(Battercake battercake){ super(battercake); } protected void doSomething(){} protected String getMsg(){ return super.</description>
    </item>
    
    <item>
      <title>模板模式和适配器模式</title>
      <link>https://ruichunjie.github.io/2019/templateandadapter20190320/</link>
      <pubDate>Wed, 20 Mar 2019 12:39:09 +0800</pubDate>
      
      <guid>https://ruichunjie.github.io/2019/templateandadapter20190320/</guid>
      <description>1.模板模式
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;模板模式通常又叫模板方法模式(Template Method Pattern)是指定义一个算法的骨 架，并允许子类为一个或者多个步骤提供实现。模板方法使得子类可以在不改变算法结 构的情况下，重新定义算法的某些步骤，属于行为性设计模式。模板方法适用于以下应 用场景:
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1)一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2)各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复。
public interface RowMapper&amp;lt;T&amp;gt;{ T mapRow(ResultSet rs, int rowNum) throws Exception; } public abstract class JdbcTemplate{ private DataSource dataSource; public JdbcTemplate(DataSource dataSource){ this.dataSource = dataSource; } public List&amp;lt;?&amp;gt; executeQuery(String sql, RowMapper&amp;lt;?&amp;gt; rowMapper, Object[] values){ try{ //1.获得连接 Connection conn = this.getConnection(); //2.创建语句集 PreparedStatement pstm = this.createPrepareStatement(conn,sql); //3.执行语句集 ResultSet rs = this.executeQuery(pstm,values); //4.处理结果集 List&amp;lt;?&amp;gt; result=this.paresResultSet(rs,rowMapper); //5.关闭结果集 this.closeResultSet(rs); //6.关闭语句集 this.closeStatement(pstm); //7.关闭连接 this.closeConnection(conn); return result; }catch(Exception e){ e.</description>
    </item>
    
    <item>
      <title>委派模式和策略模式</title>
      <link>https://ruichunjie.github.io/2019/delegateandstrategy20190320/</link>
      <pubDate>Wed, 20 Mar 2019 05:10:19 +0800</pubDate>
      
      <guid>https://ruichunjie.github.io/2019/delegateandstrategy20190320/</guid>
      <description>1.委派模式
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;委派模式(Delegate Pattern)的基本作用就是负责任务的调度和分配任务，跟代理模式很像，可以看做是一种特殊情况下的静态代理的全权代理，但是代理模式注重过程，而委派模式注重结果。不属于GOF23种设计模式之一，行为型模式，Delegate，Dispatch 结尾的一般都是代理模式。如BeanDefinitionParserDelegate
/** * 模拟SpringMVC 的 DispatcherServlet */ public class SystemController{ public void logout(){} } public class DispatcherServlet extends HttpServlet{ private void doDispatch(HttpServletRequest request, HttpServletResponse response ) throws Exception{ String uri = request.getRequestURI(); String mid = request.getParameter(&amp;quot;mid&amp;quot;); if(&amp;quot;logout&amp;quot;.equals(mid)){ new SystemController().logout(); }else{ response.getWriter().write(&amp;quot;404&amp;quot;); } } protected void service(HttpServletRequest request,HttpServletResponse response)throw ServletException,IOException{ try{ doDispatch(req,resp); }catch(Exception e){ e.printStackTrace(); } } }  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;web-app xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns=&amp;quot;http://java.sun.com/xml/ns/j2ee&amp;quot; xmlns:javaee=&amp;quot;http://java.sun.com/xml/ns/javaee&amp;quot; xmlns:web=&amp;quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&amp;quot; xsi:schemaLocation=&amp;quot;http://java.sun.com/xml/ns/j2ee http://java.</description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>https://ruichunjie.github.io/2019/proxy20190319/</link>
      <pubDate>Tue, 19 Mar 2019 12:55:52 +0800</pubDate>
      
      <guid>https://ruichunjie.github.io/2019/proxy20190319/</guid>
      <description>1.代理模式
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;代理模式(Proxy Pattern)是指为其他对象提供一种代理，以控制对这个对象的访问。代理对象在客服端和目标对象之间起到中介作用，代理模式属于结构型设计模式。使用 代理模式主要有两个目的:一保护目标对象，二增强目标对象。有静态代理和动态代理。
2.静态代理
3.动态代理
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;jdk动态代理
public class JDKproxy implements InvocationHandler{ privte Person target; public Object getInstance(Person target) throws Exception{ this.target = target; Class&amp;lt;?&amp;gt; clazz = target.getClass(); return Proxy.newProxyInstance(clazz.getClassLoader(),clazz.getInterfaces(),this); } public Object invoke(Object proxy, Method method,Object[] args)throws Exception{ before(); Object obj = method.invoke(this.target,args); after(); return obj; } public void before(){} public void after(){} }  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;JDK Proxy 生成对象的步骤
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1)拿到被代理对象的引用并获取所有的接口，反射获取
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2)JDK Proxy类重新生成新的类，同时新的类要实现被代理类所实现的所有的接口
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3)动态生成Java代码，把新加的业务逻辑方法由一定的逻辑代码去调用(在代码中体现)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;4)编译新生成的Java代码.class
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;5)重新加载到JVM中运行
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;自定义生成动态反射
/** * @Author:ChunJieRen * @Date:2019/3/13 16:56 * @Description: 1.</description>
    </item>
    
    <item>
      <title>原型模式</title>
      <link>https://ruichunjie.github.io/2019/prototype20190319/</link>
      <pubDate>Tue, 19 Mar 2019 12:33:42 +0800</pubDate>
      
      <guid>https://ruichunjie.github.io/2019/prototype20190319/</guid>
      <description>1.原型模式
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原型模式(Prototype Pattern)是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原型模式主要适用于以下场景:
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1、类初始化消耗资源较多。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2、new 产生的一个对象需要非常繁琐的过程(数据准备、访问权限等)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3、构造函数比较复杂。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;4、循环体中生产大量对象时。
2.原型模式的实现
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1)简单克隆
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;复制的不是值，而是引用的地址。浅克隆。只是完整 复制了值类型数据，没有赋值引用对象。换言之，所有的引用对象仍然指向原来的对象
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2)深度克隆
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;克隆破坏单例模式
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ArrayList 就实现了 Cloneable 接口
public Object clone() { try { ArrayList&amp;lt;?&amp;gt; v = (ArrayList&amp;lt;?&amp;gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn&#39;t happen, since we are Cloneable throw new InternalError(e); } }  </description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://ruichunjie.github.io/2019/singleton20190318/</link>
      <pubDate>Mon, 18 Mar 2019 22:32:49 +0800</pubDate>
      
      <guid>https://ruichunjie.github.io/2019/singleton20190318/</guid>
      <description>1.什么是单例模式
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 单例模式(Singleton Pattern)是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。单例模式是创建型模式。 ServletContext,ServletContextConfig,ApplicationContext,数据库的连接池都是单例形式
2.单例的实现
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1)饿汉式单例
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 在类加载时就立刻初始化，并且创建单例对象，绝对线程安全。优点是没有加任何锁，执行效率高，在用户体验上，比饿汉式要好，缺点是类加载时就初始化，不管用与不用都占着空间，浪费了内存。适用单例对象较少的情况。
public class HungryStaticSingleton{ private static final HungrySingleton hungrysingleton = new HungrySingleton(); private HungrySingleton(){} public static HungrySingleton getInstance(){return hungrysingleton;} }  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2)懒汉式单例 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;被外部类调用的时候内部类才会加载。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; synchronized 静态方法
public class LazySimpleSingleton{ private LazySimpleSingleton(){} private static LazySimpleSingleton lazy = null; public synchronized static LazySimpleSingleton getInstance(){ if(null == lazy){ lazy = new LazySimpleSingleton(); } return lazy; } }  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 双重检查锁
public class LazyDoubleCheckSingleton{ private volatile static LazyDoubleCheckSingleton lazy = null; private LazyDoubleCheckSingleton(){} public static LazyDoubleCheckSingleton getInstance(){ if(null == lazy){ synchronized(LazyDoubleCheckSingleton.</description>
    </item>
    
    <item>
      <title>mybatis基础</title>
      <link>https://ruichunjie.github.io/2019/mybatis20190317/</link>
      <pubDate>Sun, 17 Mar 2019 22:32:49 +0800</pubDate>
      
      <guid>https://ruichunjie.github.io/2019/mybatis20190317/</guid>
      <description>1.什么是mybatis
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MyBatis 是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。
2.使用mybatis
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1) 编程式
String resource = &amp;quot;org/mybatis/example/mybatis-config.xml&amp;quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt; &amp;lt;!DOCTYPE configuration PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot; &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;environments default=&amp;quot;development&amp;quot;&amp;gt; &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt; &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;/&amp;gt; &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${driver}&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${url}&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${username}&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${password}&amp;quot;/&amp;gt; &amp;lt;/dataSource&amp;gt; &amp;lt;/environment&amp;gt; &amp;lt;/environments&amp;gt; &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&amp;quot;org/mybatis/example/BlogMapper.xml&amp;quot;/&amp;gt; &amp;lt;/mappers&amp;gt; &amp;lt;/configuration&amp;gt;  DataSource dataSource = BlogDataSourceFactory.</description>
    </item>
    
    <item>
      <title>工厂模式</title>
      <link>https://ruichunjie.github.io/2019/factorydesignprinciple20190316/</link>
      <pubDate>Sat, 16 Mar 2019 22:32:49 +0800</pubDate>
      
      <guid>https://ruichunjie.github.io/2019/factorydesignprinciple20190316/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Spring中用到了很多设计模式，如工厂模式，装饰者模式，代理模式，单例模式，委派模式，策略模式，适配器模式，模板方式模式，观察者模式。设计思路，Spring IOC 工厂，单例，装饰器 。Spring AOP 代理， 观察者。 Spring MVC 委派，适配器，Spring JDBC模板方法。
1.简单工厂模式
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;简单工厂模式(Simple Factory Pattern)是指由一个工厂对象 决定创建出哪一种产品类的实例。属于创建型模式，但它不属于GOF，23种设计模式。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;工厂类负责创建的对象较少。客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心。但是工厂类的职责相对过重，增加新的产品时需要修改工厂类的判断逻辑，违背开闭原则。不易于扩展过于复杂的产品结构。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;代码过于简单，不演示了，在JDK中存在Calendar.getInstance()方法
public static Calendar getInstance() { return createCalendar(TimeZone.getDefault(),	Locale.getDefault(Locale.Category.FORMAT)); } private static Calendar createCalendar(TimeZone zone, Locale aLocale) { CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale) .getCalendarProvider(); if (provider != null) { try { return provider.getInstance(zone, aLocale); } catch (IllegalArgumentException iae) { // fall back to the default instantiation } } Calendar cal = null; if (aLocale.</description>
    </item>
    
    <item>
      <title>软件架构七大原则</title>
      <link>https://ruichunjie.github.io/2019/sevendesignprinciple20190311/</link>
      <pubDate>Mon, 11 Mar 2019 22:32:49 +0800</pubDate>
      
      <guid>https://ruichunjie.github.io/2019/sevendesignprinciple20190311/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;虽然总是说设计模式，然而感觉在开发中却很少用到。想抽点时间深入学习下设计模式。而在学习设计模式前，先来了解下软件架构七大原则。
1.开闭原则
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;开闭原则(Open-Closed Principle, OCP)是指一个软件实体如类、模块和函数应该对 扩展开放，对修改关闭。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调 的是用抽象构建框架，用实现扩展细节。实现开闭原则的核心思想就是面向抽象编程。如下示例:
/** * 课程接口 */ public interface ICourse{ Integer getId(); String getName(); Double getPrice(); } /** * java课程 如果此时java课程做活动怎么写呢？ */ public class JavaCourse implements ICourse{ private Integer Id; private String name; private Double price; public JavaCourse(Integer id, String name, Double price){ this.Id = id; this.name = name; this.price = price; } public Integer getId(){ return Id; } public String getName(){ return name; } public String getPrice(){ return price; } } /** * java折扣类 */ public class JavaDiscountCourse extends JavaCourse{ public JavaDiscountCourse(Integer id, String name, Double price){ super(id,name,price); } public Double getOriginPrice(){ return super.</description>
    </item>
    
  </channel>
</rss>